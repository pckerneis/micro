<!DOCTYPE html>
<html>
<head>
    <title>GraphParser + AudioEngine Integration Test</title>
    <style>
        body { 
            font-family: monospace; 
            margin: 20px; 
            background: #1e1e1e; 
            color: #d4d4d4; 
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #444;
            border-radius: 8px;
        }
        .code-editor {
            background: #2d2d2d;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 15px;
            font-family: monospace;
            color: #d4d4d4;
            width: 100%;
            min-height: 200px;
            resize: vertical;
        }
        .controls {
            margin: 15px 0;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .btn {
            background: #0969da;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn:hover {
            background: #0860ca;
        }
        .btn:disabled {
            background: #444;
            cursor: not-allowed;
        }
        .output {
            background: #0d1117;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            white-space: pre-wrap;
            font-family: monospace;
            max-height: 300px;
            overflow-y: auto;
        }
        .success { color: #51cf66; }
        .error { color: #ff6b6b; }
        .info { color: #74c0fc; }
        .split-view {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        h1, h2 { color: #f8f9fa; }
    </style>
</head>
<body>
    <div class="container">
        <h1>GraphParser + AudioEngine Integration Test</h1>
        <p>This demonstrates the decoupled architecture: GraphParser - AudioEngine via GraphAdapter</p>

        <div class="section">
            <h2>Code Editor</h2>
            <textarea class="code-editor" id="codeEditor" placeholder="Enter your audio routing code here...">-- Simple example
lead = sine{decay=0.1, sustain=0} -> gain{value=0.5}
pad = sine{decay=0.3, sustain=0.8}

# Routing
lead -> MASTER
pad -> gain{value=0.3} -> MASTER

# Patterns
@lead [70 _ 74 _] 0.25
@pad [60 64 67] 2.0</textarea>

            <div class="controls">
                <button class="btn" onclick="parseCode()">Parse Code</button>
                <button class="btn" onclick="applyToEngine()" id="applyBtn" disabled>Apply to Audio Engine</button>
                <button class="btn" onclick="playAudio()" id="playBtn" disabled>Play</button>
                <button class="btn" onclick="stopAudio()" id="stopBtn" disabled>Stop</button>
                <button class="btn" onclick="showGraph()" id="graphBtn" disabled>Show Graph</button>
            </div>
        </div>

        <div class="split-view">
            <div class="section">
                <h2>Parser Output</h2>
                <div class="output" id="parserOutput">Click "Parse Code" to see the parsed graph structure...</div>
            </div>

            <div class="section">
                <h2>Audio Engine Status</h2>
                <div class="output" id="engineOutput">Click "Apply to Audio Engine" to see integration results...</div>
            </div>
        </div>

        <div class="section">
            <h2>Integration Log</h2>
            <div class="output" id="integrationLog">Integration events will appear here...</div>
        </div>
    </div>

    <!-- Modal for graph visualization -->
    <dialog class="graph-modal" id="graphModal" style="border: none; border-radius: 8px; background: #1e1e1e; color: #d4d4d4; max-width: 90vw; max-height: 90vh; padding: 0;">
        <div style="background: #2d2d2d; padding: 15px 20px; border-bottom: 1px solid #444; display: flex; justify-content: space-between; align-items: center;">
            <h3 style="margin: 0; font-size: 18px;">Audio Graph Visualization</h3>
            <button onclick="closeGraph()" style="background: none; border: none; color: #d4d4d4; font-size: 24px; cursor: pointer; padding: 0; width: 30px; height: 30px;">&times;</button>
        </div>
        <div style="padding: 20px; overflow: auto; max-height: calc(90vh - 80px);">
            <div style="background: white; border-radius: 4px; padding: 20px; margin: 10px 0;">
                <div id="mermaidGraph"></div>
            </div>
        </div>
    </dialog>

    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <script src="graph-parser.js?v=7"></script>
    <script src="audio-engine.js?v=7"></script>
    <script src="graph-adapter.js?v=7"></script>
    <script>
        // Initialize Mermaid
        mermaid.initialize({ 
            startOnLoad: false,
            theme: 'default',
            flowchart: { useMaxWidth: true, htmlLabels: true }
        });

        // Global state
        let parsedGraph = null;
        let audioEngine = null;
        let integrationResult = null;

        // Initialize audio engine
        async function initAudioEngine() {
            if (!audioEngine) {
                audioEngine = new AudioEngine();
                await audioEngine.init();
                
                // Debug: Check if applyParsedGraph method exists after initialization
                log('Audio engine initialized', 'info');
                log(`applyParsedGraph method exists: ${typeof audioEngine.applyParsedGraph === 'function'}`, 'info');
                
                if (typeof audioEngine.applyParsedGraph !== 'function') {
                    log(`Available methods: ${Object.getOwnPropertyNames(Object.getPrototypeOf(audioEngine)).join(', ')}`, 'info');
                }
            }
        }

        // Parse the code
        function parseCode() {
            const code = document.getElementById('codeEditor').value;
            const parser = new GraphParser();
            
            log('Parsing code...', 'info');
            parsedGraph = parser.parse(code);
            
            // Display parser output
            let output = '';
            
            if (parsedGraph.nodes.size > 0) {
                output += '=== NODES ===\n';
                for (const [name, node] of parsedGraph.nodes) {
                    output += `${name}: ${node.type} ${JSON.stringify(node.parameters)}\n`;
                }
                output += '\n';
            }
            
            if (parsedGraph.connections.length > 0) {
                output += '=== CONNECTIONS ===\n';
                for (const conn of parsedGraph.connections) {
                    output += `${conn.from} -> ${conn.to}\n`;
                }
                output += '\n';
            }
            
            if (parsedGraph.patterns.size > 0) {
                output += '=== PATTERNS ===\n';
                for (const [name, pattern] of parsedGraph.patterns) {
                    output += `@${name} [${pattern.notes.join(' ')}] ${pattern.duration}\n`;
                }
                output += '\n';
            }
            
            if (parsedGraph.errors.length > 0) {
                output += '=== ERRORS ===\n';
                for (const error of parsedGraph.errors) {
                    output += `ERROR: ${error}\n`;
                }
            }
            
            document.getElementById('parserOutput').innerHTML = output || 'No output generated';
            document.getElementById('parserOutput').className = parsedGraph.errors.length > 0 ? 'output error' : 'output success';
            
            // Enable apply button
            document.getElementById('applyBtn').disabled = false;
            document.getElementById('graphBtn').disabled = false;
            
            log(`Parsing complete: ${parsedGraph.nodes.size} nodes, ${parsedGraph.connections.length} connections, ${parsedGraph.patterns.size} patterns`, 
                 parsedGraph.errors.length > 0 ? 'error' : 'success');
        }

        // Apply parsed graph to audio engine
        async function applyToEngine() {
            if (!parsedGraph) {
                log('No parsed graph available', 'error');
                return;
            }

            await initAudioEngine();
            
            log('Applying parsed graph to audio engine...', 'info');
            
            try {
                // Debug: Check if the method exists
                if (typeof audioEngine.applyParsedGraph !== 'function') {
                    log(`ERROR: applyParsedGraph is not a function. Type: ${typeof audioEngine.applyParsedGraph}`, 'error');
                    log(`AudioEngine methods: ${Object.getOwnPropertyNames(Object.getPrototypeOf(audioEngine)).join(', ')}`, 'info');
                    return;
                }
                
                // This is where the decoupled architecture shines:
                // The parser output is passed to the audio engine via the adapter
                integrationResult = audioEngine.applyParsedGraph(parsedGraph);
            } catch (error) {
                log(`ERROR during integration: ${error.message}`, 'error');
                log(`Error stack: ${error.stack}`, 'error');
                return;
            }
            
            // Display integration results
            let output = `=== INTEGRATION RESULTS ===\n`;
            output += `Success: ${integrationResult.success}\n`;
            output += `Nodes Created: ${integrationResult.nodesCreated}\n`;
            output += `Connections Created: ${integrationResult.connectionsCreated}\n`;
            output += `Patterns Created: ${integrationResult.patternsCreated}\n\n`;
            
            if (integrationResult.errors.length > 0) {
                output += `=== INTEGRATION ERRORS ===\n`;
                for (const error of integrationResult.errors) {
                    output += `ERROR: ${error}\n`;
                }
            }
            
            // Show current audio engine state
            output += `\n=== AUDIO ENGINE STATE ===\n`;
            output += `Instruments: ${audioEngine.instruments.size}\n`;
            output += `Patterns: ${audioEngine.patterns.size}\n`;
            output += `Named Effects: ${audioEngine.namedEffects.size}\n`;
            
            document.getElementById('engineOutput').innerHTML = output;
            document.getElementById('engineOutput').className = integrationResult.success ? 'output success' : 'output error';
            
            // Enable play button if successful
            document.getElementById('playBtn').disabled = !integrationResult.success;
            
            log(`Integration ${integrationResult.success ? 'successful' : 'failed'}`, 
                 integrationResult.success ? 'success' : 'error');
        }

        // Play audio
        function playAudio() {
            if (!audioEngine || !integrationResult?.success) {
                log('Audio engine not ready', 'error');
                return;
            }
            
            audioEngine.play();
            document.getElementById('playBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            log('Audio playback started', 'success');
        }

        // Stop audio
        function stopAudio() {
            if (!audioEngine) {
                log('Audio engine not available', 'error');
                return;
            }
            
            audioEngine.stop();
            document.getElementById('playBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            log('Audio playback stopped', 'info');
        }

        // Show graph visualization
        function showGraph() {
            if (!parsedGraph) {
                log('No parsed graph available', 'error');
                return;
            }

            const mermaidCode = generateMermaidGraph(parsedGraph);
            const graphContainer = document.getElementById('mermaidGraph');
            graphContainer.innerHTML = '';
            
            const graphId = 'integration-graph-' + Date.now();
            
            mermaid.render(graphId, mermaidCode).then(({svg}) => {
                graphContainer.innerHTML = svg;
                document.getElementById('graphModal').showModal();
            }).catch(error => {
                console.error('Mermaid rendering error:', error);
                graphContainer.innerHTML = `<pre style="color: red;">Error rendering graph:\n${error.message}</pre>`;
                document.getElementById('graphModal').showModal();
            });
        }

        function closeGraph() {
            document.getElementById('graphModal').close();
        }

        // Generate Mermaid graph (simplified version)
        function generateMermaidGraph(result) {
            let mermaid = 'flowchart TD\n';
            
            // Add nodes with readable names
            const nodeDisplayNames = new Map();
            let anonCounter = 1;
            
            for (const [name, node] of result.nodes) {
                if (name.startsWith('_anon_')) {
                    nodeDisplayNames.set(name, `${node.type}${anonCounter}`);
                    anonCounter++;
                } else {
                    nodeDisplayNames.set(name, name);
                }
            }
            
            for (const [name, node] of result.nodes) {
                const displayName = nodeDisplayNames.get(name);
                const params = Object.keys(node.parameters).length > 0 
                    ? '<br/>' + Object.entries(node.parameters)
                        .map(([k, v]) => `${k}=${v}`)
                        .join('<br/>')
                    : '';
                
                mermaid += `    ${name}["${displayName}${params}"]\n`;
            }
            
            // Add MASTER output if referenced
            let hasMasterOutput = false;
            for (const conn of result.connections) {
                if (conn.to === 'MASTER') {
                    hasMasterOutput = true;
                    break;
                }
            }
            if (hasMasterOutput) {
                mermaid += '    MASTER["MASTER OUTPUT"]\n';
            }
            
            // Add connections
            for (const conn of result.connections) {
                mermaid += `    ${conn.from} --> ${conn.to}\n`;
            }
            
            // Add patterns
            if (result.patterns.size > 0) {
                mermaid += '\n    %% Patterns\n';
                for (const [name, pattern] of result.patterns) {
                    const patternId = `pattern_${name}`;
                    mermaid += `    ${patternId}["@${name}<br/>[${pattern.notes.join(' ')}]<br/>duration: ${pattern.duration}"]\n`;
                    mermaid += `    ${patternId} -.-> ${name}\n`;
                }
            }
            
            return mermaid;
        }

        // Logging function
        function log(message, type = 'info') {
            const logElement = document.getElementById('integrationLog');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}\n`;
            
            logElement.innerHTML += `<span class="${type}">${logEntry}</span>`;
            logElement.scrollTop = logElement.scrollHeight;
        }

        // Initialize
        window.addEventListener('load', () => {
            log('Integration test page loaded', 'info');
            log('Ready to test GraphParser → AudioEngine integration', 'info');
        });
    </script>
</body>
</html>
