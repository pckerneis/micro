<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio System Tests</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            margin: 20px;
            line-height: 1.6;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #3c3c3c;
            border-radius: 5px;
        }
        .test-result {
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
        }
        .test-pass {
            background: #0d4f2c;
            border-left: 4px solid #4ec9b0;
        }
        .test-fail {
            background: #4f1414;
            border-left: 4px solid #f44747;
        }
        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background: #1177bb;
        }
        .code {
            background: #2d2d30;
            padding: 10px;
            border-radius: 3px;
            font-family: 'Consolas', monospace;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>üß™ Simplified Audio System Tests</h1>
    
    <div class="test-section">
        <h2>AudioGraphBuilder Tests</h2>
        <button onclick="testAudioGraphBuilder()">Run AudioGraphBuilder Tests</button>
        <div id="graphBuilderResults"></div>
    </div>

    <div class="test-section">
        <h2>UnifiedInstrument Tests</h2>
        <button onclick="testUnifiedInstrument()">Run UnifiedInstrument Tests</button>
        <div id="instrumentResults"></div>
    </div>

    <div class="test-section">
        <h2>Effect Chain Tests</h2>
        <button onclick="testEffectChains()">Run Effect Chain Tests</button>
        <div id="effectChainResults"></div>
    </div>

    <div class="test-section">
        <h2>Integration Tests</h2>
        <button onclick="testIntegration()">Run Integration Tests</button>
        <div id="integrationResults"></div>
    </div>

    <div class="test-section">
        <h2>Audio Playback Tests</h2>
        <button onclick="testAudioPlayback()">Test Audio Playback</button>
        <div id="playbackResults"></div>
        <p><em>Note: These tests will actually play audio. Make sure your volume is at a comfortable level.</em></p>
    </div>

    <!-- Load the audio system files -->
    <script src="audio-graph-builder.js"></script>
    <script src="unified-instrument.js"></script>

    <script>
        let audioContext;
        let graphBuilder;
        let masterGain;

        // Initialize audio context for testing
        async function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.connect(audioContext.destination);
                masterGain.gain.value = 0.3; // Lower volume for testing
                graphBuilder = new AudioGraphBuilder(audioContext, masterGain);
            }
        }

        // Test result helper
        function addTestResult(containerId, testName, passed, message = '') {
            const container = document.getElementById(containerId);
            const result = document.createElement('div');
            result.className = `test-result ${passed ? 'test-pass' : 'test-fail'}`;
            result.innerHTML = `
                <strong>${passed ? '‚úÖ' : '‚ùå'} ${testName}</strong>
                ${message ? `<br><small>${message}</small>` : ''}
            `;
            container.appendChild(result);
        }

        // AudioGraphBuilder Tests
        async function testAudioGraphBuilder() {
            await initAudio();
            const container = document.getElementById('graphBuilderResults');
            container.innerHTML = '';

            try {
                // Test effect node creation
                const delayEffect = { type: 'delay', time: 0.5 };
                const delayNode = graphBuilder.createEffectNode(delayEffect);
                addTestResult('graphBuilderResults', 'Create Delay Node', 
                    delayNode && delayNode.delayTime && delayNode.delayTime.value === 0.5,
                    'Delay node created with correct time parameter');

                const lowpassEffect = { type: 'lowpass', cutoff: 800 };
                const filterNode = graphBuilder.createEffectNode(lowpassEffect);
                addTestResult('graphBuilderResults', 'Create Lowpass Node',
                    filterNode && filterNode.frequency && filterNode.frequency.value === 800,
                    'Lowpass filter created with correct cutoff frequency');

                const gainEffect = { type: 'gain', level: 0.5 };
                const gainNode = graphBuilder.createEffectNode(gainEffect);
                addTestResult('graphBuilderResults', 'Create Gain Node',
                    gainNode && gainNode.gain && gainNode.gain.value === 0.5,
                    'Gain node created with correct level');

                // Test unknown effect type
                const unknownEffect = { type: 'unknown' };
                const unknownNode = graphBuilder.createEffectNode(unknownEffect);
                addTestResult('graphBuilderResults', 'Handle Unknown Effect',
                    unknownNode === null,
                    'Unknown effect type returns null');

                // Test oscillator with envelope
                const { oscillator, gainNode: envGain } = graphBuilder.createOscillatorWithEnvelope(
                    440, 'sine', { attack: 0.1, decay: 0.2, sustain: 0.5, release: 0.3 }, 1.0
                );
                addTestResult('graphBuilderResults', 'Create Oscillator with Envelope',
                    oscillator && oscillator.frequency.value === 440 && envGain,
                    'Oscillator and envelope gain node created correctly');

            } catch (error) {
                addTestResult('graphBuilderResults', 'AudioGraphBuilder Error', false, error.message);
            }
        }

        // UnifiedInstrument Tests
        async function testUnifiedInstrument() {
            await initAudio();
            const container = document.getElementById('instrumentResults');
            container.innerHTML = '';

            try {
                // Test oscillator instrument creation
                const oscConfig = {
                    type: 'oscillator',
                    oscillatorType: 'square',
                    attack: 0.01,
                    decay: 0.1,
                    sustain: 0.5,
                    release: 0.2
                };
                const oscInstrument = new UnifiedInstrument(audioContext, masterGain, oscConfig, graphBuilder);
                addTestResult('instrumentResults', 'Create Oscillator Instrument',
                    oscInstrument.instrumentType === 'oscillator' && oscInstrument.oscillatorType === 'square',
                    'Oscillator instrument created with correct configuration');

                // Test sample instrument creation
                const sampleConfig = {
                    type: 'sample',
                    url: './samples/kick.wav',
                    gain: 0.8
                };
                const sampleInstrument = new UnifiedInstrument(audioContext, masterGain, sampleConfig, graphBuilder);
                addTestResult('instrumentResults', 'Create Sample Instrument',
                    sampleInstrument.instrumentType === 'sample' && sampleInstrument.gain === 0.8,
                    'Sample instrument created with correct configuration');

                // Test effect chain setting
                const effectChains = [
                    [{ type: 'lowpass', cutoff: 1000 }, { type: 'gain', level: 0.7 }]
                ];
                oscInstrument.setEffectChains(effectChains);
                addTestResult('instrumentResults', 'Set Effect Chains',
                    oscInstrument.effectChains.length === 1 && oscInstrument.effectChains[0].length === 2,
                    'Effect chains set correctly');

                // Test note to frequency conversion
                const freq440 = oscInstrument.noteToFreq(69); // A4 = 440Hz
                const freq880 = oscInstrument.noteToFreq(81); // A5 = 880Hz
                addTestResult('instrumentResults', 'Note to Frequency Conversion',
                    Math.abs(freq440 - 440) < 0.1 && Math.abs(freq880 - 880) < 0.1,
                    `A4 = ${freq440.toFixed(1)}Hz, A5 = ${freq880.toFixed(1)}Hz`);

            } catch (error) {
                addTestResult('instrumentResults', 'UnifiedInstrument Error', false, error.message);
            }
        }

        // Effect Chain Tests
        async function testEffectChains() {
            await initAudio();
            const container = document.getElementById('effectChainResults');
            container.innerHTML = '';

            try {
                // Create a test source
                const testOsc = audioContext.createOscillator();
                testOsc.frequency.value = 440;
                testOsc.type = 'sine';

                // Test single effect chain
                const singleChain = [
                    { type: 'lowpass', cutoff: 500 },
                    { type: 'gain', level: 0.5 }
                ];
                
                const finalNode = graphBuilder.buildEffectChain(testOsc, singleChain, masterGain);
                addTestResult('effectChainResults', 'Build Single Effect Chain',
                    finalNode !== null,
                    'Single effect chain built successfully');

                // Test empty effect chain
                const testOsc2 = audioContext.createOscillator();
                testOsc2.frequency.value = 440;
                const directNode = graphBuilder.buildEffectChain(testOsc2, [], masterGain);
                addTestResult('effectChainResults', 'Build Empty Effect Chain',
                    directNode === testOsc2,
                    'Empty effect chain connects directly to output');

                // Test parallel chains
                const testOsc3 = audioContext.createOscillator();
                testOsc3.frequency.value = 440;
                const parallelChains = [
                    [{ type: 'lowpass', cutoff: 1000 }],
                    [{ type: 'gain', level: 0.3 }]
                ];
                
                // This should not throw an error
                graphBuilder.buildParallelChains(testOsc3, parallelChains, masterGain);
                addTestResult('effectChainResults', 'Build Parallel Effect Chains',
                    true,
                    'Parallel effect chains built without errors');

            } catch (error) {
                addTestResult('effectChainResults', 'Effect Chain Error', false, error.message);
            }
        }

        // Integration Tests
        async function testIntegration() {
            await initAudio();
            const container = document.getElementById('integrationResults');
            container.innerHTML = '';

            try {
                // Test complete instrument with effects
                const config = {
                    type: 'oscillator',
                    oscillatorType: 'sine',
                    attack: 0.01,
                    decay: 0.1,
                    sustain: 0.3,
                    release: 0.2
                };
                
                const instrument = new UnifiedInstrument(audioContext, masterGain, config, graphBuilder);
                
                // Set up effect chain
                const effectChains = [
                    [
                        { type: 'lowpass', cutoff: 800 },
                        { type: 'gain', level: 0.6 }
                    ]
                ];
                instrument.setEffectChains(effectChains);

                addTestResult('integrationResults', 'Complete Instrument Setup',
                    instrument.effectChains.length === 1,
                    'Instrument created and configured with effect chain');

                // Test that play method doesn't throw errors
                let playError = null;
                try {
                    // Don't actually play - just test the setup
                    // instrument.play(60, 0, 0.1);
                } catch (error) {
                    playError = error;
                }
                
                addTestResult('integrationResults', 'Play Method Integration',
                    playError === null,
                    'Play method executes without errors');

            } catch (error) {
                addTestResult('integrationResults', 'Integration Error', false, error.message);
            }
        }

        // Audio Playback Tests (actually plays sound)
        async function testAudioPlayback() {
            await initAudio();
            const container = document.getElementById('playbackResults');
            container.innerHTML = '';

            try {
                // Test 1: Simple oscillator
                const oscConfig = {
                    type: 'oscillator',
                    oscillatorType: 'sine',
                    attack: 0.01,
                    decay: 0.1,
                    sustain: 0.3,
                    release: 0.2
                };
                
                const oscInstrument = new UnifiedInstrument(audioContext, masterGain, oscConfig, graphBuilder);
                oscInstrument.play(60, audioContext.currentTime, 0.5); // C4 for 0.5 seconds
                
                addTestResult('playbackResults', 'Oscillator Playback',
                    true,
                    'Playing C4 sine wave for 0.5 seconds');

                // Test 2: Oscillator with effects
                setTimeout(() => {
                    const effectChains = [
                        [
                            { type: 'lowpass', cutoff: 400 },
                            { type: 'gain', level: 0.7 }
                        ]
                    ];
                    oscInstrument.setEffectChains(effectChains);
                    oscInstrument.play(64, audioContext.currentTime, 0.5); // E4 with effects
                    
                    addTestResult('playbackResults', 'Oscillator with Effects',
                        true,
                        'Playing E4 with lowpass filter and gain');
                }, 600);

                // Test 3: Different waveform
                setTimeout(() => {
                    const squareConfig = {
                        type: 'oscillator',
                        oscillatorType: 'square',
                        attack: 0.01,
                        decay: 0.05,
                        sustain: 0.8,
                        release: 0.1
                    };
                    
                    const squareInstrument = new UnifiedInstrument(audioContext, masterGain, squareConfig, graphBuilder);
                    squareInstrument.play(67, audioContext.currentTime, 0.3); // G4 square wave
                    
                    addTestResult('playbackResults', 'Square Wave Playback',
                        true,
                        'Playing G4 square wave for 0.3 seconds');
                }, 1200);

            } catch (error) {
                addTestResult('playbackResults', 'Playback Error', false, error.message);
            }
        }

        // Run all tests
        async function runAllTests() {
            await testAudioGraphBuilder();
            await testUnifiedInstrument();
            await testEffectChains();
            await testIntegration();
        }
    </script>

    <div style="margin-top: 30px; padding: 20px; background: #2d2d30; border-radius: 5px;">
        <h3>üöÄ Quick Test</h3>
        <button onclick="runAllTests()" style="background: #4ec9b0; color: #1e1e1e;">Run All Tests</button>
        <p>This will run all unit tests for the simplified audio system components.</p>
    </div>
</body>
</html>
